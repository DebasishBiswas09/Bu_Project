{"ast":null,"code":"var _s = $RefreshSig$();\n\nexport const usePagination = ({\n  totalCount,\n  pageSize,\n  siblingCount = 1,\n  currentPage\n}) => {\n  _s();\n\n  const paginationRange = useMemo(() => {\n    const totalPageCount = Math.ceil(totalCount / pageSize); // Pages count is determined as siblingCount + firstPage + lastPage + currentPage + 2*DOTS\n\n    const totalPageNumbers = siblingCount + 5;\n    /*\r\n      Case 1:\r\n      If the number of pages is less than the page numbers we want to show in our\r\n      paginationComponent, we return the range [1..totalPageCount]\r\n    */\n\n    if (totalPageNumbers >= totalPageCount) {\n      return range(1, totalPageCount);\n    }\n    /*\r\n    \tCalculate left and right sibling index and make sure they are within range 1 and totalPageCount\r\n    */\n\n\n    const leftSiblingIndex = Math.max(currentPage - siblingCount, 1);\n    const rightSiblingIndex = Math.min(currentPage + siblingCount, totalPageCount);\n    /*\r\n      We do not show dots just when there is just one page number to be inserted between the extremes of sibling and the page limits i.e 1 and totalPageCount. Hence we are using leftSiblingIndex > 2 and rightSiblingIndex < totalPageCount - 2\r\n    */\n\n    const shouldShowLeftDots = leftSiblingIndex > 2;\n    const shouldShowRightDots = rightSiblingIndex < totalPageCount - 2;\n    const firstPageIndex = 1;\n    const lastPageIndex = totalPageCount;\n    /*\r\n    \tCase 2: No left dots to show, but rights dots to be shown\r\n    */\n\n    if (!shouldShowLeftDots && shouldShowRightDots) {\n      let leftItemCount = 3 + 2 * siblingCount;\n      let leftRange = range(1, leftItemCount);\n      return [...leftRange, DOTS, totalPageCount];\n    }\n    /*\r\n    \tCase 3: No right dots to show, but left dots to be shown\r\n    */\n\n\n    if (shouldShowLeftDots && !shouldShowRightDots) {\n      let rightItemCount = 3 + 2 * siblingCount;\n      let rightRange = range(totalPageCount - rightItemCount + 1, totalPageCount);\n      return [firstPageIndex, DOTS, ...rightRange];\n    }\n    /*\r\n    \tCase 4: Both left and right dots to be shown\r\n    */\n\n\n    if (shouldShowLeftDots && shouldShowRightDots) {\n      let middleRange = range(leftSiblingIndex, rightSiblingIndex);\n      return [firstPageIndex, DOTS, ...middleRange, DOTS, lastPageIndex];\n    }\n  }, [totalCount, pageSize, siblingCount, currentPage]);\n  return paginationRange;\n};\n\n_s(usePagination, \"tLviJI6rwkyze3+kNwkFLwjvB48=\");","map":{"version":3,"sources":["D:/GNIT/Eighth Semester/Capgemini/BU/Code - Copy/src/components/usePagination.js"],"names":["usePagination","totalCount","pageSize","siblingCount","currentPage","paginationRange","useMemo","totalPageCount","Math","ceil","totalPageNumbers","range","leftSiblingIndex","max","rightSiblingIndex","min","shouldShowLeftDots","shouldShowRightDots","firstPageIndex","lastPageIndex","leftItemCount","leftRange","DOTS","rightItemCount","rightRange","middleRange"],"mappings":";;AACA,OAAO,MAAMA,aAAa,GAAG,CAAC;AAC5BC,EAAAA,UAD4B;AAE5BC,EAAAA,QAF4B;AAG5BC,EAAAA,YAAY,GAAG,CAHa;AAI5BC,EAAAA;AAJ4B,CAAD,KAKvB;AAAA;;AACJ,QAAMC,eAAe,GAAGC,OAAO,CAAC,MAAM;AACpC,UAAMC,cAAc,GAAGC,IAAI,CAACC,IAAL,CAAUR,UAAU,GAAGC,QAAvB,CAAvB,CADoC,CAGpC;;AACA,UAAMQ,gBAAgB,GAAGP,YAAY,GAAG,CAAxC;AAEA;AACJ;AACA;AACA;AACA;;AACI,QAAIO,gBAAgB,IAAIH,cAAxB,EAAwC;AACtC,aAAOI,KAAK,CAAC,CAAD,EAAIJ,cAAJ,CAAZ;AACD;AAED;AACJ;AACA;;;AACI,UAAMK,gBAAgB,GAAGJ,IAAI,CAACK,GAAL,CAAST,WAAW,GAAGD,YAAvB,EAAqC,CAArC,CAAzB;AACA,UAAMW,iBAAiB,GAAGN,IAAI,CAACO,GAAL,CACxBX,WAAW,GAAGD,YADU,EAExBI,cAFwB,CAA1B;AAKA;AACJ;AACA;;AACI,UAAMS,kBAAkB,GAAGJ,gBAAgB,GAAG,CAA9C;AACA,UAAMK,mBAAmB,GAAGH,iBAAiB,GAAGP,cAAc,GAAG,CAAjE;AAEA,UAAMW,cAAc,GAAG,CAAvB;AACA,UAAMC,aAAa,GAAGZ,cAAtB;AAEA;AACJ;AACA;;AACI,QAAI,CAACS,kBAAD,IAAuBC,mBAA3B,EAAgD;AAC9C,UAAIG,aAAa,GAAG,IAAI,IAAIjB,YAA5B;AACA,UAAIkB,SAAS,GAAGV,KAAK,CAAC,CAAD,EAAIS,aAAJ,CAArB;AAEA,aAAO,CAAC,GAAGC,SAAJ,EAAeC,IAAf,EAAqBf,cAArB,CAAP;AACD;AAED;AACJ;AACA;;;AACI,QAAIS,kBAAkB,IAAI,CAACC,mBAA3B,EAAgD;AAC9C,UAAIM,cAAc,GAAG,IAAI,IAAIpB,YAA7B;AACA,UAAIqB,UAAU,GAAGb,KAAK,CACpBJ,cAAc,GAAGgB,cAAjB,GAAkC,CADd,EAEpBhB,cAFoB,CAAtB;AAIA,aAAO,CAACW,cAAD,EAAiBI,IAAjB,EAAuB,GAAGE,UAA1B,CAAP;AACD;AAED;AACJ;AACA;;;AACI,QAAIR,kBAAkB,IAAIC,mBAA1B,EAA+C;AAC7C,UAAIQ,WAAW,GAAGd,KAAK,CAACC,gBAAD,EAAmBE,iBAAnB,CAAvB;AACA,aAAO,CAACI,cAAD,EAAiBI,IAAjB,EAAuB,GAAGG,WAA1B,EAAuCH,IAAvC,EAA6CH,aAA7C,CAAP;AACD;AACF,GA9D8B,EA8D5B,CAAClB,UAAD,EAAaC,QAAb,EAAuBC,YAAvB,EAAqCC,WAArC,CA9D4B,CAA/B;AAgEA,SAAOC,eAAP;AACD,CAvEM;;GAAML,a","sourcesContent":["\r\nexport const usePagination = ({\r\n  totalCount,\r\n  pageSize,\r\n  siblingCount = 1,\r\n  currentPage,\r\n}) => {\r\n  const paginationRange = useMemo(() => {\r\n    const totalPageCount = Math.ceil(totalCount / pageSize);\r\n\r\n    // Pages count is determined as siblingCount + firstPage + lastPage + currentPage + 2*DOTS\r\n    const totalPageNumbers = siblingCount + 5;\r\n\r\n    /*\r\n      Case 1:\r\n      If the number of pages is less than the page numbers we want to show in our\r\n      paginationComponent, we return the range [1..totalPageCount]\r\n    */\r\n    if (totalPageNumbers >= totalPageCount) {\r\n      return range(1, totalPageCount);\r\n    }\r\n\r\n    /*\r\n    \tCalculate left and right sibling index and make sure they are within range 1 and totalPageCount\r\n    */\r\n    const leftSiblingIndex = Math.max(currentPage - siblingCount, 1);\r\n    const rightSiblingIndex = Math.min(\r\n      currentPage + siblingCount,\r\n      totalPageCount\r\n    );\r\n\r\n    /*\r\n      We do not show dots just when there is just one page number to be inserted between the extremes of sibling and the page limits i.e 1 and totalPageCount. Hence we are using leftSiblingIndex > 2 and rightSiblingIndex < totalPageCount - 2\r\n    */\r\n    const shouldShowLeftDots = leftSiblingIndex > 2;\r\n    const shouldShowRightDots = rightSiblingIndex < totalPageCount - 2;\r\n\r\n    const firstPageIndex = 1;\r\n    const lastPageIndex = totalPageCount;\r\n\r\n    /*\r\n    \tCase 2: No left dots to show, but rights dots to be shown\r\n    */\r\n    if (!shouldShowLeftDots && shouldShowRightDots) {\r\n      let leftItemCount = 3 + 2 * siblingCount;\r\n      let leftRange = range(1, leftItemCount);\r\n\r\n      return [...leftRange, DOTS, totalPageCount];\r\n    }\r\n\r\n    /*\r\n    \tCase 3: No right dots to show, but left dots to be shown\r\n    */\r\n    if (shouldShowLeftDots && !shouldShowRightDots) {\r\n      let rightItemCount = 3 + 2 * siblingCount;\r\n      let rightRange = range(\r\n        totalPageCount - rightItemCount + 1,\r\n        totalPageCount\r\n      );\r\n      return [firstPageIndex, DOTS, ...rightRange];\r\n    }\r\n\r\n    /*\r\n    \tCase 4: Both left and right dots to be shown\r\n    */\r\n    if (shouldShowLeftDots && shouldShowRightDots) {\r\n      let middleRange = range(leftSiblingIndex, rightSiblingIndex);\r\n      return [firstPageIndex, DOTS, ...middleRange, DOTS, lastPageIndex];\r\n    }\r\n  }, [totalCount, pageSize, siblingCount, currentPage]);\r\n\r\n  return paginationRange;\r\n};\r\n"]},"metadata":{},"sourceType":"module"}